# go-gb
Golang practice


##HW-6
1. Проанализируйте задания предыдущих уроков.
   a. **Q:** В каких случаях необходима была явная передача указателя в качестве входных параметров и возвращаемых результатов или в качестве приёмника в методах?
   **A:** На примере предыдущих уроков, передача указателя в качестве параметров была нужна в случаях когда рекурсивно работать с мапой (в предыдущем задании), где  
   переход от передачи по значению (через копирование объекта) к передаче по ссылке (через поинтер) позволил еще в несколько раз ускорить оптимизированный подсчет чисел Фибоначчи через рекурсию, результат по скорости приближается к наиболее оптимальному - подсчет в памяти, без рекурсии.
   Результат следующий:
   Фибоначчи 45-е число, методом обычной рекурсии: 7.117149724s
   Фибоначчи 45-е число, методом рекурсии с кешированием в мапе: 23.74µs
   Фибоначчи 45-е число, методом рекурсии с кешированием в мапе + передача по ссылке: 7.396µs
   b. **Q:** В каких случаях мы фактически имеем дело с указателями при передаче параметров, хотя явно их не указываем?
   **A:** Например, в случае использования defer, значения захватываются по указателю при передаче в функции внутри блока. Когда передаем в параметре слайс или мапу.

2. **Q:** Для арифметического умножения и разыменования указателей в Go используется один и тот же символ — оператор (*). Как вы думаете, как компилятор Go понимает, в каких случаях в выражении имеется в виду умножение, а в каких — разыменование указателя?
   **A:** При использовании арифметического умножения компилятор ожидает значения двух переменных, оператор разыменывания же является префиксом единственной переменной. Соответственно если переменная одна, значит * это префикс и оператор разыменывания, иначе умножение.


##HW-5
### Назначение
Приложение использует инициализированное в main() значение num := 30 для подсчета чисел Фибоначчи двумя разными реализациями

### Структура
Приложение разделено на:
1. **main.go** - реализует общую логику работы приложения:
2. **fibonacci.go** - реализует методы получения подсчета чисел Фибоначчи двумя реализациями:
- Fib(n int) int - обычный способ, через рекурсию
- GetFibonacci(n int) int - улучшенный способ, через рекурсию и хранение значений в map[int]int
3. **fibonacci_test.go** - unit-тесты для обоих методов реализации:
В тесте используется мапа со значениями от 0 до 20, и проверка на соответствие предопределенного значения полученному 

##HW-4
### Назначение
Приложение принимает на вход набор целых чисел и выводит его же в отсортированном виде. На данный момент реализован алгоритм сортировки методом вставки.
Приложение размещено в /pkg/my_sort для дальнейшего использования.

### Структура
Приложение разделено на:
1. **main.go** - точка входа 
2. **my_sort.go** - реализует общую логику работы приложения и последующего расширения логики: 
> добавление альтернативных способов ввода (файл, канал, сокет?);
> добавление альтернативных алгоритмов сортировки;
> добавление альтернативных способов вывода (файл, канал, сокет?);

3. **request.go** - реализует методы получения входных данных;
4. **data_prepare.go** - реализует обработку и подготовку данных;
5. **inserts_sort.go** - реализует алгоритм сортировки вставками
6. **respond.go** - реализует методы вывода данных;
7. **helper.go** - реализует вспомогательные функции внутреннего использования.
